import {
  BaseQueryState,
  BuildQuery,
  CursorState,
  IteratePagination,
  VulnerabilityAlertResponse,
} from '../types';
import fragments from '../fragments';
import { MAX_REQUESTS_LIMIT } from '../paginate';
import utils, { EnterpriseFeatures } from '../utils';

interface QueryState extends BaseQueryState {
  vulnerabilityAlerts: CursorState;
}

type QueryParams = {
  login: string;
  repoName: string;
  stateFilter: string[];
  severityFilter: string[];
  gheServerVersion?: string;
};

const ALL_ALERT_STATES = ['FIXED', 'DISMISSED', 'OPEN'];

const buildQuery: BuildQuery<QueryParams, QueryState> = (
  queryParams,
  queryState,
) => {
  const versionSafeFragments = buildVersionSafeFragments(
    queryParams.gheServerVersion,
  );

  const query = `
    ${versionSafeFragments.query}
      repository(owner: $login, name: $repoName) {
        ${versionSafeFragments.vulnerabilityAlerts}
          nodes {
            id
            repository {
              nameWithOwner          
            }
            createdAt
            dismissReason
            dismissedAt
            dismisser {
              login
              name
              email
            }
            ${versionSafeFragments.additionalFields}            
            securityAdvisory {
              cvss {
                vectorString
                score
              }
              cwes(first: $maxLimit) {
                nodes {
                  cweId
                  name
                  description
                }
              }
              databaseId
              description
              ghsaId
              id
              identifiers {
                type
                value
              }
              notificationsPermalink
              origin
              permalink
              publishedAt
              references {
                url
              }
              severity
              summary
              updatedAt
              withdrawnAt
            }
            securityVulnerability {
              firstPatchedVersion {
                identifier
              }
              package {
                name
                ecosystem
              }
              severity
              updatedAt
              vulnerableVersionRange
            }
            vulnerableManifestFilename
            vulnerableManifestPath
            vulnerableRequirements
          }
          pageInfo {
            endCursor
            hasNextPage
          }
        }
      }
      ...${fragments.rateLimit}
    }`;

  const states =
    queryParams.stateFilter.length === 0
      ? ALL_ALERT_STATES
      : queryParams.stateFilter;

  return {
    query,
    ...(queryState?.rateLimit && {
      rateLimit: queryState.rateLimit,
    }),
    queryVariables: {
      login: queryParams.login,
      repoName: queryParams.repoName,
      states,
      maxLimit: MAX_REQUESTS_LIMIT,
      ...(queryState?.vulnerabilityAlerts?.hasNextPage && {
        alertsCursor: queryState.vulnerabilityAlerts.endCursor,
      }),
    },
  };
};

/**
 * Depending on the version of GHE Server, provide a supported query.
 * @param gheServerVersion
 */
const buildVersionSafeFragments = (
  gheServerVersion?: string,
): { query: string; vulnerabilityAlerts: string; additionalFields: string } => {
  const fragments = {
    query: '',
    vulnerabilityAlerts: '',
    additionalFields: '',
  };

  if (
    utils.isSupported(
      EnterpriseFeatures.REPO_VULN_ALERT_STATE_ARG,
      gheServerVersion,
    )
  ) {
    fragments.query =
      'query ($login: String!, $repoName: String!, $states: [RepositoryVulnerabilityAlertState!]!, $maxLimit: Int!, $alertsCursor: String) {\n';
    fragments.vulnerabilityAlerts =
      'vulnerabilityAlerts(first: $maxLimit, after: $alertsCursor, states: $states) {\n';
  } else {
    fragments.query =
      'query ($login: String!, $repoName: String!, $maxLimit: Int!, $alertsCursor: String) {\n';
    fragments.vulnerabilityAlerts =
      'vulnerabilityAlerts(first: $maxLimit, after: $alertsCursor) {\n';
  }

  if (
    utils.isSupported(
      EnterpriseFeatures.REPO_VULN_ALERT_FIELDS,
      gheServerVersion,
    )
  ) {
    fragments.additionalFields = 'fixReason\n fixedAt\n number\n state';
  }

  return fragments;
};

const processResponseData = async (
  responseData,
  severityFilter: string[],
  iteratee,
) => {
  const rateLimit = responseData.rateLimit;
  const vulnAlertNodes =
    responseData.repository?.vulnerabilityAlerts?.nodes ?? [];

  for (const node of vulnAlertNodes) {
    if (!utils.hasProperties(node)) {
      continue;
    }

    // If severity filter is empty, skip the check.
    if (
      severityFilter.length > 0 &&
      !severityFilter.includes(node.securityAdvisory?.severity)
    ) {
      continue;
    }

    const vulnAlert: VulnerabilityAlertResponse = {
      ...node,
      ...(node.securityAdvisory && {
        securityAdvisory: {
          ...node.securityAdvisory,
          cwes: node.securityAdvisory?.cwes?.nodes ?? [],
        },
      }),
    };

    await iteratee(vulnAlert);
  }

  return {
    rateLimit,
    vulnerabilityAlerts: responseData.repository?.vulnerabilityAlerts?.pageInfo,
  };
};

const iterateVulnerabilityAlerts: IteratePagination<
  QueryParams,
  VulnerabilityAlertResponse
> = async (queryParams, execute, iteratee) => {
  let queryCost = 0;
  let queryState: QueryState | undefined = undefined;
  let paginationComplete = false;

  const isPaginationComplete = (queryState) =>
    !queryState?.vulnerabilityAlerts?.hasNextPage ?? true;
  const countIteratee = async (resource) => {
    await iteratee(resource);
  };

  while (!paginationComplete) {
    const executable = buildQuery(queryParams, queryState);

    const response = await execute(executable);

    queryState = await processResponseData(
      response,
      queryParams.severityFilter,
      countIteratee,
    );

    queryCost += queryState?.rateLimit?.cost ?? 0;

    paginationComplete = isPaginationComplete(queryState);
  }

  return {
    totalCost: queryCost,
    limit: queryState?.rateLimit?.limit,
    remaining: queryState?.rateLimit?.remaining,
    resetAt: queryState?.rateLimit?.resetAt,
  };
};

export default { iterateVulnerabilityAlerts };
