import {
  createDirectRelationship,
  IntegrationMissingKeyError,
  IntegrationStep,
  IntegrationStepExecutionContext,
  JobState,
  RelationshipClass,
} from '@jupiterone/integration-sdk-core';
import { IntegrationConfig } from '../config';
import { RepoData, VulnerabilityAlertEntity } from '../types';
import {
  GITHUB_REPO_TAGS_ARRAY,
  GithubEntities,
  IngestionSources,
  MappedRelationships,
  Relationships,
  Steps,
  VULN_ALERTS_TOTAL_BY_REPO,
} from '../constants';
import {
  createCveEntity,
  createCweEntity,
  createFindingCveRelationship,
  createFindingCweRelationship,
  createVulnerabilityAlertEntity,
} from '../sync/converters';
import { findCve } from '../sync/converterUtils';
import {
  getOrCreateGraphqlClient,
  VulnerabilityAlertResponse,
} from '../client/GraphQLClient';
import { withBatching } from '../client/GraphQLClient/batchUtils';

export async function fetchVulnAlerts({
  instance,
  logger,
  jobState,
}: IntegrationStepExecutionContext<IntegrationConfig>) {
  const { config } = instance;
  const graphqlClient = getOrCreateGraphqlClient(config, logger);

  const repoTags = await jobState.getData<Map<string, RepoData>>(
    GITHUB_REPO_TAGS_ARRAY,
  );
  if (!repoTags) {
    throw new IntegrationMissingKeyError(
      `Expected repos.ts to have set ${GITHUB_REPO_TAGS_ARRAY} in jobState.`,
    );
  }

  const vulnAlertsTotalByRepo = await jobState.getData<Map<string, number>>(
    VULN_ALERTS_TOTAL_BY_REPO,
  );
  if (!vulnAlertsTotalByRepo) {
    return;
  }

  const iteratee = buildIteratee({
    jobState,
    config,
  });

  await withBatching({
    totalConnectionsById: vulnAlertsTotalByRepo,
    threshold: 100,
    batchCb: async (repoIds) => {
      await graphqlClient.iterateRepoVulnAlerts(repoIds, iteratee);
    },
    singleCb: async (repoId) => {
      const repoData = repoTags.get(repoId);
      if (!repoData) {
        return;
      }
      await graphqlClient.iterateRepoVulnAlerts(repoData.name, iteratee);
    },
    logger,
  });

  await jobState.deleteData(VULN_ALERTS_TOTAL_BY_REPO);
}

function buildIteratee({
  jobState,
  config,
}: {
  jobState: JobState;
  config: IntegrationConfig;
}) {
  return async (vulnAlert: VulnerabilityAlertResponse) => {
    const vulnAlertEntity = (await jobState.addEntity(
      createVulnerabilityAlertEntity(vulnAlert, config.githubApiBaseUrl),
    )) as VulnerabilityAlertEntity;

    if (vulnAlert.repoId) {
      await jobState.addRelationship(
        createDirectRelationship({
          _class: RelationshipClass.HAS,
          fromType: GithubEntities.GITHUB_REPO._type,
          fromKey: vulnAlert.repoId,
          toType: GithubEntities.GITHUB_VULNERABILITY_ALERT._type,
          toKey: vulnAlertEntity._key,
        }),
      );
    }

    const cve = findCve(vulnAlert);
    if (cve) {
      const cvss = vulnAlert.securityAdvisory?.cvss;
      const cveEntity = createCveEntity(cve, cvss);

      await jobState.addRelationship(
        createFindingCveRelationship(vulnAlertEntity, cveEntity),
      );
    }

    const cwes = vulnAlert.securityAdvisory?.cwes ?? [];
    await Promise.all(
      cwes.map(async (cwe) => {
        const cweEntity = createCweEntity(cwe);

        await jobState.addRelationship(
          createFindingCweRelationship(vulnAlertEntity, cweEntity),
        );
      }),
    );
  };
}

export const vulnerabilityAlertsSteps: IntegrationStep<IntegrationConfig>[] = [
  {
    id: Steps.FETCH_VULNERABILITY_ALERTS,
    ingestionSourceId: IngestionSources.VULNERABILITY_ALERTS,
    name: 'Fetch Vulnerability Alerts',
    entities: [GithubEntities.GITHUB_VULNERABILITY_ALERT],
    relationships: [Relationships.REPO_HAS_FINDING],
    mappedRelationships: [
      MappedRelationships.FINDING_IS_CVE,
      MappedRelationships.FINDING_EXPLOITS_CWE,
    ],
    dependsOn: [Steps.FETCH_REPOS],
    executionHandler: fetchVulnAlerts,
  },
];
