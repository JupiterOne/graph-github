import { Recording } from '@jupiterone/integration-sdk-testing';
import { sanitizeConfig } from '../config';
import { integrationConfig } from '../../test/config';
import { setupGithubRecording } from '../../test/recording';
import {
  GithubEntities,
  MappedRelationships,
  Relationships,
} from '../constants';
import { invocationConfig } from '..';
import { executeStepWithDependencies } from '../../test/executeStepWithDependencies';
import { vulnerabilityAlertsSteps } from './vulnerabilityAlertsSteps';

jest.setTimeout(100000);

let recording: Recording;
afterEach(async () => {
  await recording.stop();
});

describe('vulnerabilityAlertsStep', () => {
  test('fetchVulnerabilityAlerts exec handler', async () => {
    recording = setupGithubRecording({
      directory: __dirname,
      name: 'vulnAlerts',
    });
    sanitizeConfig(integrationConfig);

    const { collectedEntities, collectedRelationships, encounteredTypes } =
      await executeStepWithDependencies({
        stepId: vulnerabilityAlertsSteps[0].id,
        invocationConfig: invocationConfig as any,
        instanceConfig: integrationConfig,
      });

    expect({
      numCollectedEntities: collectedEntities.length,
      numCollectedRelationships: collectedRelationships.length,
      collectedEntities: collectedEntities,
      collectedRelationships: collectedRelationships,
      encounteredTypes: encounteredTypes,
    }).toMatchSnapshot();

    const alerts = collectedEntities.filter(
      (e) => e._type === GithubEntities.GITHUB_VULNERABILITY_ALERT._type,
    );
    expect(alerts.length).toBeGreaterThan(0);
    expect(alerts).toMatchGraphObjectSchema({
      ...GithubEntities.GITHUB_VULNERABILITY_ALERT,
      disableClassMatch: true,
    });

    // relationships
    const repoFindings = collectedRelationships.filter(
      (e) => e._type === Relationships.REPO_HAS_FINDING._type,
    );
    expect(repoFindings.length).toBeGreaterThan(0);
    const findingCves = collectedRelationships.filter(
      (e) => e._type === MappedRelationships.FINDING_IS_CVE._type,
    );
    expect(findingCves.length).toBeGreaterThan(0);
    const findingCwes = collectedRelationships.filter(
      (e) => e._type === MappedRelationships.FINDING_EXPLOITS_CWE._type,
    );
    expect(findingCwes.length).toBeGreaterThan(0);
  });

  test('fetchVulnerabilityAlerts with filtering', async () => {
    recording = setupGithubRecording({
      directory: __dirname,
      name: 'vulnAlertsWithFiltering',
    });
    integrationConfig.dependabotAlertStates = ['OPEN'];
    integrationConfig.dependabotAlertSeverities = ['CRITICAL'];

    sanitizeConfig(integrationConfig);

    const { collectedEntities, collectedRelationships, encounteredTypes } =
      await executeStepWithDependencies({
        stepId: vulnerabilityAlertsSteps[0].id,
        invocationConfig: invocationConfig as any,
        instanceConfig: integrationConfig,
      });

    expect({
      numCollectedEntities: collectedEntities.length,
      numCollectedRelationships: collectedRelationships.length,
      collectedEntities: collectedEntities,
      collectedRelationships: collectedRelationships,
      encounteredTypes: encounteredTypes,
    }).toMatchSnapshot();

    const githubFindingEntities = collectedEntities.filter(
      (e) => e._type === 'github_finding',
    );

    expect(
      githubFindingEntities.some((entity) =>
        ['LOW', 'MODERATE', 'HIGH'].includes(entity.severity as string),
      ),
    ).toBeFalsy();
    expect(githubFindingEntities.some((entity) => !entity.open)).toBeFalsy();
  });
});
