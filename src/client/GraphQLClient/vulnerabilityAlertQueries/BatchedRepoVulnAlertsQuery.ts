import {
  BaseQueryState,
  BuildQuery,
  CursorState,
  IteratePagination,
  VulnerabilityAlertResponse,
} from '../types';
import fragments from '../fragments';
import utils from '../utils';
import {
  ALL_ALERT_STATES,
  buildVersionSafeFragments,
  vulnAlertsFields,
} from './shared';
import { MAX_REQUESTS_LIMIT } from '../paginate';

interface QueryState extends BaseQueryState {
  vulnerabilityAlerts: CursorState;
}

type QueryParams = {
  repoIds: string[];
  stateFilter: string[];
  severityFilter: string[];
  gheServerVersion?: string;
};

const buildQuery: BuildQuery<QueryParams, QueryState> = (
  queryParams,
  queryState,
) => {
  const versionSafeFragments = buildVersionSafeFragments(
    queryParams.gheServerVersion,
  );

  const query = `
    query (
      $repoIds: [ID!]!
      $states: [RepositoryVulnerabilityAlertState!]!
      $maxLimit: Int!
      $alertsCursor: String
    ) {
      nodes(ids: $repoIds) {
        ...on Repository {
          id
          ${vulnAlertsFields(versionSafeFragments)}
        }
      }
      ...${fragments.rateLimit}
    }`;

  const states =
    queryParams.stateFilter.length === 0
      ? ALL_ALERT_STATES
      : queryParams.stateFilter;

  return {
    query,
    ...(queryState?.rateLimit && {
      rateLimit: queryState.rateLimit,
    }),
    queryVariables: {
      repoIds: queryParams.repoIds,
      maxLimit: MAX_REQUESTS_LIMIT,
      states,
      ...(queryState?.vulnerabilityAlerts?.hasNextPage && {
        alertsCursor: queryState.vulnerabilityAlerts.endCursor,
      }),
    },
  };
};

const processResponseData = async (
  responseData,
  severityFilter: string[],
  iteratee,
) => {
  const rateLimit = responseData.rateLimit;
  const repositories = responseData.nodes ?? [];

  for (const repository of repositories) {
    const vulnAlertNodes = repository?.vulnerabilityAlerts?.nodes ?? [];
    for (const node of vulnAlertNodes) {
      if (!utils.hasProperties(node)) {
        continue;
      }

      // If severity filter is empty, skip the check.
      if (
        severityFilter.length > 0 &&
        !severityFilter.includes(node.securityAdvisory?.severity)
      ) {
        continue;
      }

      const vulnAlert: VulnerabilityAlertResponse = {
        repoId: repository?.id,
        ...node,
        ...(node.securityAdvisory && {
          securityAdvisory: {
            ...node.securityAdvisory,
            cwes: node.securityAdvisory?.cwes?.nodes ?? [],
          },
        }),
      };

      await iteratee(vulnAlert);
    }
  }

  return {
    rateLimit,
    vulnerabilityAlerts: responseData.repository?.vulnerabilityAlerts?.pageInfo,
  };
};

const iterateVulnerabilityAlerts: IteratePagination<
  QueryParams,
  VulnerabilityAlertResponse
> = async (queryParams, execute, iteratee) => {
  let queryCost = 0;
  let queryState: QueryState | undefined = undefined;
  let paginationComplete = false;

  const isPaginationComplete = (queryState) =>
    !queryState?.vulnerabilityAlerts?.hasNextPage ?? true;
  const countIteratee = async (resource) => {
    await iteratee(resource);
  };

  while (!paginationComplete) {
    const executable = buildQuery(queryParams, queryState);

    const response = await execute(executable);

    queryState = await processResponseData(
      response,
      queryParams.severityFilter,
      countIteratee,
    );

    queryCost += queryState?.rateLimit?.cost ?? 0;

    paginationComplete = isPaginationComplete(queryState);
  }

  return {
    totalCost: queryCost,
    limit: queryState?.rateLimit?.limit,
    remaining: queryState?.rateLimit?.remaining,
    resetAt: queryState?.rateLimit?.resetAt,
  };
};

export default { iterateVulnerabilityAlerts };
