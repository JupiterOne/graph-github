import {
  createDirectRelationship,
  IntegrationMissingKeyError,
  IntegrationStep,
  IntegrationStepExecutionContext,
  JobState,
  RelationshipClass,
} from '@jupiterone/integration-sdk-core';
import { IntegrationConfig } from '../config';
import { getOrCreateApiClient } from '../client';
import { RepoData, VulnerabilityAlertEntity } from '../types';
import {
  GITHUB_REPO_TAGS_ARRAY,
  GithubEntities,
  IngestionSources,
  MappedRelationships,
  Relationships,
  Steps,
  VULN_ALERTS_TOTAL_BY_REPO,
} from '../constants';
import {
  createCveEntity,
  createCweEntity,
  createFindingCveRelationship,
  createFindingCweRelationship,
  createVulnerabilityAlertEntity,
} from '../sync/converters';
import { findCve } from '../sync/converterUtils';
import { MAX_REQUESTS_LIMIT } from '../client/GraphQLClient/paginate';
import { VulnerabilityAlertResponse } from '../client/GraphQLClient';
import { withBatching } from '../client/GraphQLClient/batchUtils';

export async function fetchVulnAlerts({
  instance,
  logger,
  jobState,
}: IntegrationStepExecutionContext<IntegrationConfig>) {
  const { config } = instance;
  const apiClient = getOrCreateApiClient(config, logger);

  const repoTags = await jobState.getData<Map<string, RepoData>>(
    GITHUB_REPO_TAGS_ARRAY,
  );
  if (!repoTags) {
    throw new IntegrationMissingKeyError(
      `Expected repos.ts to have set ${GITHUB_REPO_TAGS_ARRAY} in jobState.`,
    );
  }

  const maxRequestLimit =
    config.dependyabotAlertRequestLimit ?? MAX_REQUESTS_LIMIT;

  const vulnAlertsTotalByRepo = await jobState.getData<Map<string, number>>(
    VULN_ALERTS_TOTAL_BY_REPO,
  );
  if (!vulnAlertsTotalByRepo) {
    return;
  }

  const iteratee = buildIteratee({
    jobState,
    config,
  });

  await withBatching({
    totalConnectionsById: vulnAlertsTotalByRepo,
    threshold: maxRequestLimit,
    batchCb: async (repoIds) => {
      await apiClient.iterateBatchedRepoVulnAlerts(repoIds, iteratee);
    },
    singleCb: async (repoId) => {
      const repoData = repoTags.get(repoId);
      if (!repoData) {
        return;
      }
      await apiClient.iterateRepoVulnAlerts(
        repoData.name,
        maxRequestLimit,
        iteratee,
      );
    },
  });

  await jobState.deleteData(VULN_ALERTS_TOTAL_BY_REPO);
}

function buildIteratee({
  jobState,
  config,
}: {
  jobState: JobState;
  config: IntegrationConfig;
}) {
  return async (vulnAlert: VulnerabilityAlertResponse) => {
    const vulnAlertEntity = (await jobState.addEntity(
      createVulnerabilityAlertEntity(vulnAlert, config.githubApiBaseUrl),
    )) as VulnerabilityAlertEntity;

    if (vulnAlert.repoId) {
      await jobState.addRelationship(
        createDirectRelationship({
          _class: RelationshipClass.HAS,
          fromType: GithubEntities.GITHUB_REPO._type,
          fromKey: vulnAlert.repoId,
          toType: GithubEntities.GITHUB_VULNERABILITY_ALERT._type,
          toKey: vulnAlertEntity._key,
        }),
      );
    }

    const cve = findCve(vulnAlert);
    if (cve) {
      const cvss = vulnAlert.securityAdvisory?.cvss;
      const cveEntity = createCveEntity(cve, cvss);

      await jobState.addRelationship(
        createFindingCveRelationship(vulnAlertEntity, cveEntity),
      );
    }

    const cwes = vulnAlert.securityAdvisory?.cwes ?? [];
    await Promise.all(
      cwes.map(async (cwe) => {
        const cweEntity = createCweEntity(cwe);

        await jobState.addRelationship(
          createFindingCweRelationship(vulnAlertEntity, cweEntity),
        );
      }),
    );
  };
}

export const vulnerabilityAlertsSteps: IntegrationStep<IntegrationConfig>[] = [
  {
    id: Steps.FETCH_VULNERABILITY_ALERTS,
    ingestionSourceId: IngestionSources.VULNERABILITY_ALERTS,
    name: 'Fetch Vulnerability Alerts',
    entities: [GithubEntities.GITHUB_VULNERABILITY_ALERT],
    relationships: [Relationships.REPO_HAS_FINDING],
    mappedRelationships: [
      MappedRelationships.FINDING_IS_CVE,
      MappedRelationships.FINDING_EXPLOITS_CWE,
    ],
    dependsOn: [
      Steps.FETCH_REPOS,
      // Added to execute steps serially.
      // https://docs.github.com/en/rest/guides/best-practices-for-using-the-rest-api?apiVersion=2022-11-28#dealing-with-secondary-rate-limits
      Steps.FETCH_CODE_SCANNING_ALERTS,
    ],
    executionHandler: fetchVulnAlerts,
  },
];
