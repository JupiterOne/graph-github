jest.setTimeout(100000);

import {
  Recording,
  executeStepWithDependencies,
} from '@jupiterone/integration-sdk-testing';
import {
  buildStepTestConfig,
  filterDirectRelationships,
} from '../../test/config';
import { setupGithubRecording } from '../../test/recording';
import { GithubEntities, Steps } from '../constants';

let recording: Recording;
afterEach(async () => {
  await recording.stop();
});

describe('filteredVulnerabilityAlertsStep', () => {
  test('fetchVulnerabilityAlerts with filtering', async () => {
    recording = setupGithubRecording({
      directory: __dirname,
      name: 'vulnAlertsWithFiltering',
    });

    const stepConfig = buildStepTestConfig(Steps.FETCH_VULNERABILITY_ALERTS);
    const stepResults = await executeStepWithDependencies({
      ...stepConfig,
      instanceConfig: {
        ...stepConfig.instanceConfig,
        dependabotAlertStates: ['OPEN'],
        dependabotAlertSeverities: ['CRITICAL'],
      },
    });

    expect({
      ...stepResults,
      // HACK: `@jupiterone/integration-sdk-testing`
      // does not currently support `toMatchStepMetadata` with mapped
      // relationships, which is causing tests to fail. We will add
      // support soon and remove this hack.
      collectedRelationships: filterDirectRelationships(
        stepResults.collectedRelationships,
      ),
    }).toMatchStepMetadata({
      ...stepConfig,
      invocationConfig: {
        ...stepConfig.invocationConfig,
        integrationSteps: stepConfig.invocationConfig.integrationSteps.map(
          (s) => {
            return {
              ...s,
              mappedRelationships: [],
            };
          },
        ),
      },
    });

    const githubFindingEntities = stepResults.collectedEntities.filter(
      (e) => e._type === GithubEntities.GITHUB_VULNERABILITY_ALERT._type,
    );

    expect(
      githubFindingEntities.some((entity) =>
        ['LOW', 'MODERATE', 'HIGH'].includes(entity.severity as string),
      ),
    ).toBeFalsy();
    expect(githubFindingEntities.some((entity) => !entity.open)).toBeFalsy();
  });
});
