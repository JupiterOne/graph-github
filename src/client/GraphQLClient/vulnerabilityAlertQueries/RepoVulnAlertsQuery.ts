import {
  BaseQueryState,
  BuildQuery,
  CursorState,
  IteratePagination,
  ProcessResponse,
  VulnerabilityAlertResponse,
} from '../types';
import fragments from '../fragments';
import paginate, { MAX_REQUESTS_LIMIT } from '../paginate';
import utils from '../utils';

interface QueryState extends BaseQueryState {
  vulnerabilityAlerts: CursorState;
}

type QueryParams = {
  login: string;
  repoName: string;
};

const buildQuery: BuildQuery<QueryParams, QueryState> = (
  queryParams,
  queryState,
) => {
  const query = `
    query ($login: String!, $repoName: String! $maxLimit: Int!, $alertsCursor: String) {
      repository(owner: $login, name: $repoName) {
        vulnerabilityAlerts(first: $maxLimit, after: $alertsCursor) {
          nodes {
            repository {
              nameWithOwner          
            }
            createdAt
            dismissReason
            dismissedAt
            dismisser {
              login
              name
              email
            }
            fixReason
            fixedAt
            number
            state
            securityAdvisory {
              cvss {
                vectorString
                score
              }
              cwes(first: $maxLimit) {
                nodes {
                  cweId
                  name
                  description
                }
              }
              databaseId
              description
              ghsaId
              id
              identifiers {
                type
                value
              }
              notificationsPermalink
              origin
              permalink
              publishedAt
              references {
                url
              }
              severity
              summary
              updatedAt
              withdrawnAt
            }
            securityVulnerability {
              firstPatchedVersion {
                identifier
              }
              package {
                name
                ecosystem
              }
              severity
              updatedAt
              vulnerableVersionRange
            }
            vulnerableManifestFilename
            vulnerableManifestPath
            vulnerableRequirements
          }
          pageInfo {
            endCursor
            hasNextPage
          }
        }
      }
      ...${fragments.rateLimit}
    }`;

  return {
    query,
    ...(queryState?.rateLimit && {
      rateLimit: queryState.rateLimit,
    }),
    queryVariables: {
      ...queryParams,
      maxLimit: MAX_REQUESTS_LIMIT,
      ...(queryState?.vulnerabilityAlerts?.hasNextPage && {
        alertsCursor: queryState.vulnerabilityAlerts.endCursor,
      }),
    },
  };
};

const processResponseData: ProcessResponse<
  VulnerabilityAlertResponse,
  QueryState
> = async (responseData, iteratee) => {
  const rateLimit = responseData.rateLimit;
  const vulnAlertNodes =
    responseData.repository?.vulnerabilityAlerts?.nodes ?? [];

  for (const node of vulnAlertNodes) {
    if (!utils.hasProperties(node)) {
      continue;
    }

    const vulnAlert: VulnerabilityAlertResponse = {
      ...node,
      ...(node.securityAdvisory && {
        securityAdvisory: {
          ...node.securityAdvisory,
          cwes: node.securityAdvisory?.cwes?.nodes ?? [],
        },
      }),
    };

    await iteratee(vulnAlert);
  }

  return {
    rateLimit,
    vulnerabilityAlerts: responseData.repository?.vulnerabilityAlerts?.pageInfo,
  };
};

const iterateVulnerabilityAlerts: IteratePagination<
  QueryParams,
  VulnerabilityAlertResponse
> = async (queryParams, execute, iteratee) => {
  return paginate(
    queryParams,
    iteratee,
    execute,
    buildQuery,
    processResponseData,
    (queryState) => !queryState?.vulnerabilityAlerts?.hasNextPage ?? true,
  );
};

export default { iterateVulnerabilityAlerts };
