import {
  BaseQueryState,
  BuildQuery,
  CursorState,
  IteratePagination,
  VulnerabilityAlertResponse,
} from '../types';
import fragments from '../fragments';
import utils from '../utils';
import {
  ALL_ALERT_STATES,
  buildVersionSafeFragments,
  vulnAlertsFields,
} from './shared';
import { buildTimeoutHandler } from '../timeoutHandler';

interface QueryState extends BaseQueryState {
  vulnerabilityAlerts: CursorState;
}

type QueryParams = {
  login: string;
  repoName: string;
  stateFilter: string[];
  severityFilter: string[];
  gheServerVersion?: string;
  /**
   * Conditionally set when too many resources are being requested.
   */
  maxRequestLimit: number;
};

const buildQuery: BuildQuery<QueryParams, QueryState> = (
  queryParams,
  queryState,
) => {
  const versionSafeFragments = buildVersionSafeFragments(
    queryParams.gheServerVersion,
  );

  const query = `
    ${versionSafeFragments.query}
      repository(owner: $login, name: $repoName) {
        id
        ${vulnAlertsFields(versionSafeFragments)}
      }
      ...${fragments.rateLimit}
    }`;

  const states =
    queryParams.stateFilter.length === 0
      ? ALL_ALERT_STATES
      : queryParams.stateFilter;

  return {
    query,
    ...(queryState?.rateLimit && {
      rateLimit: queryState.rateLimit,
    }),
    queryVariables: {
      login: queryParams.login,
      repoName: queryParams.repoName,
      states,
      maxLimit: queryParams.maxRequestLimit,
      ...(queryState?.vulnerabilityAlerts?.hasNextPage && {
        alertsCursor: queryState.vulnerabilityAlerts.endCursor,
      }),
    },
  };
};

const processResponseData = async (
  responseData,
  severityFilter: string[],
  iteratee,
) => {
  const rateLimit = responseData.rateLimit;
  const vulnAlertNodes =
    responseData.repository?.vulnerabilityAlerts?.nodes ?? [];

  console.log('Executed vulnerability alerts query');

  for (const node of vulnAlertNodes) {
    if (!utils.hasProperties(node)) {
      continue;
    }

    // If severity filter is empty, skip the check.
    if (
      severityFilter.length > 0 &&
      !severityFilter.includes(node.securityAdvisory?.severity)
    ) {
      continue;
    }

    const vulnAlert: VulnerabilityAlertResponse = {
      repoId: responseData.repository?.id,
      ...node,
      ...(node.securityAdvisory && {
        securityAdvisory: {
          ...node.securityAdvisory,
          cwes: node.securityAdvisory?.cwes?.nodes ?? [],
        },
      }),
    };

    await iteratee(vulnAlert);
  }

  return {
    rateLimit,
    vulnerabilityAlerts: responseData.repository?.vulnerabilityAlerts?.pageInfo,
  };
};

const iterateVulnerabilityAlerts: IteratePagination<
  QueryParams,
  VulnerabilityAlertResponse
> = async (queryParams, execute, iteratee, logger) => {
  let queryCost = 0;
  let queryState: QueryState | undefined = undefined;
  let paginationComplete = false;

  const isPaginationComplete = (queryState) =>
    !queryState?.vulnerabilityAlerts?.hasNextPage ?? true;
  const countIteratee = async (resource) => {
    await iteratee(resource);
  };

  const withTimeoutHandler = buildTimeoutHandler({
    queryParams,
    maxLimitKey: 'maxRequestLimit',
    logger,
  });

  while (!paginationComplete) {
    const executable = buildQuery(queryParams, queryState);

    const { response, retry } = await withTimeoutHandler(async () =>
      execute(executable),
    );

    if (retry) {
      continue;
    }

    queryState = await processResponseData(
      response,
      queryParams.severityFilter,
      countIteratee,
    );

    queryCost += queryState?.rateLimit?.cost ?? 0;

    paginationComplete = isPaginationComplete(queryState);
  }

  return {
    totalCost: queryCost,
    limit: queryState?.rateLimit?.limit,
    remaining: queryState?.rateLimit?.remaining,
    resetAt: queryState?.rateLimit?.resetAt,
  };
};

export default { iterateVulnerabilityAlerts };
