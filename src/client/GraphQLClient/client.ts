import graphql, { GraphQLClient } from 'graphql.js';

import {
  IntegrationLogger,
  IntegrationProviderAPIError,
  IntegrationProviderAuthenticationError,
  parseTimePropertyValue,
} from '@jupiterone/integration-sdk-core';
import { retry } from '@lifeomic/attempt';
import { Octokit } from '@octokit/rest';

import { ResourceIteratee } from '../../client';
import validateGraphQLResponse from '../../util/validateGraphQLReponse';
import fragments from './fragments';

import {
  Collaborator,
  Issue,
  OrgMemberQueryResponse,
  OrgRepoQueryResponse,
  OrgTeamMemberQueryResponse,
  OrgTeamQueryResponse,
  OrgTeamRepoQueryResponse,
  PullRequest,
  RateLimitStepSummary,
} from './types';
import PullRequestsQuery from './pullRequestQueries/PullRequestsQuery';
import IssuesQuery from './issueQueries/IssuesQuery';
import { createQueryExecutor } from './CreateQueryExecutor';
import OrgRepositoriesQuery from './repositoryQueries/OrgRepositoriesQuery';
import TeamRepositoriesQuery from './repositoryQueries/TeamRepositoriesQuery';
import OrgMembersQuery from './memberQueries/OrgMembersQuery';
import TeamMembersQuery from './memberQueries/TeamMembersQuery';
import TeamsQuery from './teamQueries/TeamsQuery';
import RepoCollaboratorsQuery from './collaboratorQueries/RepoCollaboratorsQuery';
import OrganizationQuery, {
  OrganizationResults,
} from './organizationQueries/OrganizationQuery';

const FIVE_MINUTES_IN_MILLIS = 300000;

export class GitHubGraphQLClient {
  private readonly graphqlUrl: string;

  /**
   * A function generated by `graphql()` that is bound to authentication
   * parameters. Changes to auth require regenerating the function.
   *
   * @throws GraphQLError, which you can read about at
   * https://github.com/f/graphql.js/blob/4d3c2eb726e711baf58f45c613ebfd5c34c55218/graphql.js#L325
   *
   * Forms of the error we've seen:
   * - The complete response object is rejected on a non-200 response:
   *   { "data": null, "errors": [{ "message": string }]} }
   * - Only the "errors" array is rejected on a `200` response:
   *   [{
   *      "type": "FORBIDDEN",
   *      "path": ["search","edges",6,"node","mergeCommit"],
   *      "extensions": { "saml_failure": false },
   *      "locations": [
   *        {
   *          "line": 143,
   *          "column": 5
   *        }
   *      ],
   *      "message": "Resource not accessible by integration"
   *    },
   *    ...
   *  ]
   */
  private graph: GraphQLClient;

  private logger: IntegrationLogger;
  private authClient: Octokit;
  private tokenExpires: number;
  private rateLimitStatus: {
    limit: number;
    remaining: number;
    resetAt: string;
  };

  constructor(
    graphqlUrl: string,
    token: string,
    tokenExpires: number,
    logger: IntegrationLogger,
    authClient: Octokit,
  ) {
    this.graphqlUrl = graphqlUrl;
    this.graph = graphql(this.graphqlUrl, {
      headers: {
        'User-Agent': 'jupiterone-graph-github',
        Authorization: `token ${token}`,
      },
      asJSON: true,
    });
    this.graph.fragment(fragments);
    this.tokenExpires = tokenExpires;
    this.logger = logger;
    this.authClient = authClient;
  }

  private collectRateLimitStatus(results: RateLimitStepSummary) {
    if (results.limit && results.remaining && results.resetAt) {
      this.rateLimitStatus = {
        limit: results.limit,
        remaining: results.remaining,
        resetAt: results.resetAt,
      };
    }

    return results;
  }

  get rateLimit() {
    return this.rateLimitStatus;
  }

  /**
   * Refreshes the token and reinitialize the graphql client.
   * @private
   */
  private async refreshToken() {
    try {
      const { token, expiresAt } = (await this.authClient.auth({
        type: 'installation',
        refresh: true, //required or else client will return the previous token from cache
      })) as {
        token: string;
        expiresAt: string;
      };
      this.graph = graphql(this.graphqlUrl, {
        headers: {
          'User-Agent': 'jupiterone-graph-github',
          Authorization: `token ${token}`,
        },
        asJSON: true,
      });
      this.graph.fragment(fragments);
      this.tokenExpires = parseTimePropertyValue(expiresAt) || 0;
    } catch (err) {
      throw new IntegrationProviderAuthenticationError({
        cause: err,
        endpoint: err.response?.url,
        status: err.status,
        statusText: err.response?.data?.message,
      });
    }
  }

  /**
   * Performs GraphQl request.
   * Handles:
   *    - token management (refreshes 5 minutes before expiring)
   *    - rate limit management
   * @param queryString
   * @param queryVariables
   */
  public async query(queryString: string, queryVariables) {
    if (this.tokenExpires - FIVE_MINUTES_IN_MILLIS < Date.now()) {
      await this.refreshToken();
    }

    return await this.retryGraphQL(queryString, queryVariables);
  }

  /**
   * Fetches organization associated with the provided login.
   * @param login
   */
  public async fetchOrganization(login: string): Promise<OrganizationResults> {
    const executor = createQueryExecutor(this, this.logger);

    const results = await OrganizationQuery.fetchOrganization(login, executor);

    this.collectRateLimitStatus(results.rateLimit);

    return results;
  }

  /**
   * Iterates over pull requests for the given repository.
   * @param repository
   * @param lastExecutionTime
   * @param iteratee
   */
  public async iteratePullRequests(
    repository: { fullName: string; public: boolean },
    lastExecutionTime: string,
    iteratee: ResourceIteratee<PullRequest>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await PullRequestsQuery.iteratePullRequests(
        {
          ...repository,
          lastExecutionTime,
        },
        executor,
        iteratee,
      ),
    );
  }

  /**
   * Iterates over issues for the given repository.
   * @param repoFullName
   * @param lastExecutionTime
   * @param iteratee
   */
  public async iterateIssues(
    repoFullName: string,
    lastExecutionTime: string,
    iteratee: ResourceIteratee<Issue>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await IssuesQuery.iterateIssues(
        { repoFullName, lastExecutionTime },
        executor,
        iteratee,
      ),
    );
  }

  /**
   * Iterates over Organization repositories.
   * @param login
   * @param iteratee
   */
  public async iterateOrgRepositories(
    login,
    iteratee: ResourceIteratee<OrgRepoQueryResponse>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await OrgRepositoriesQuery.iterateRepositories(login, executor, iteratee),
    );
  }

  /**
   * Iterate teams found within an organization.
   * @param login aka organization
   * @param iteratee
   */
  public async iterateTeams(
    login: string,
    iteratee: ResourceIteratee<OrgTeamQueryResponse>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await TeamsQuery.iterateTeams(login, executor, iteratee),
    );
  }

  /**
   * Iterate repository collaborators within an organization.
   * @param login aka organization
   * @param repoName
   * @param iteratee
   */
  public async iterateRepoCollaborators(
    login,
    repoName,
    iteratee: ResourceIteratee<Collaborator>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await RepoCollaboratorsQuery.iterateCollaborators(
        {
          login,
          repoName,
        },
        executor,
        iteratee,
      ),
    );
  }

  /**
   * Iterates over repositories for the given org & team.
   * @param login - aka organization
   * @param teamSlug
   * @param iteratee
   */
  public async iterateTeamRepositories(
    login: string,
    teamSlug: string,
    iteratee: ResourceIteratee<OrgTeamRepoQueryResponse>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await TeamRepositoriesQuery.iterateRepositories(
        {
          login,
          teamSlug,
        },
        executor,
        iteratee,
      ),
    );
  }

  /**
   * Iterates over members of the given org.
   * @param login - aka organization
   * @param iteratee
   */
  public async iterateOrgMembers(
    login,
    iteratee: ResourceIteratee<OrgMemberQueryResponse>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await OrgMembersQuery.iterateMembers(login, executor, iteratee),
    );
  }

  /**
   * Iterates over members of the given org & team.
   * @param login
   * @param teamSlug
   * @param iteratee
   */
  public async iterateTeamMembers(
    login: string,
    teamSlug: string,
    iteratee: ResourceIteratee<OrgTeamMemberQueryResponse>,
  ): Promise<RateLimitStepSummary> {
    const executor = createQueryExecutor(this, this.logger);

    return this.collectRateLimitStatus(
      await TeamMembersQuery.iterateMembers(
        { login, teamSlug },
        executor,
        iteratee,
      ),
    );
  }

  /**
   *
   * @param queryString
   * @param queryVariables
   * @private
   */
  private async retryGraphQL(queryString: string, queryVariables) {
    const { logger } = this;

    //queryWithRateLimitCatch will be passed to the retry function below
    const queryWithRateLimitCatch = async () => {
      let response;
      try {
        response = await this.graph(queryString)(queryVariables);
      } catch (err) {
        // Process errors thrown by `this.graph` generated functions
        let message;

        // Extract message from first GraphQL response (reject(response),
        // unknown response code in graphql.js)
        if (err.errors?.length > 0 && err.errors[0].message) {
          message = `GraphQL errors (${
            err.errors.length
          }), first: ${JSON.stringify(err.errors[0])}`;
        }

        // Catch all, we could get an Array from graphql.js (reject(response.errors))
        if (!message) {
          message = JSON.stringify(err).substring(0, 200);
        }

        //just wrapping the original error so we can be more specific about the string that caused it
        throw new IntegrationProviderAPIError({
          message,
          status: 'None',
          statusText: `GraphQL query error: ${queryString}`,
          cause: err,
          endpoint: `retryGraphQL`,
        });
      }
      validateGraphQLResponse(response, logger, queryString);
      return response;
    };

    // Check https://github.com/lifeomic/attempt for options on retry
    return await retry(queryWithRateLimitCatch, {
      maxAttempts: 3,
      delay: 30_000, // 30 seconds to start
      timeout: 180_000, // 3 min timeout. We need this in case Node hangs with ETIMEDOUT
      factor: 2, //exponential backoff factor. with 30 sec start and 3 attempts, longest wait is 2 min
      handleError: async (err, attemptContext) => {
        /* retry will keep trying to the limits of retryOptions
         * but it lets you intervene in this function - if you throw an error from in here,
         * it stops retrying. Otherwise, you can just log the attempts.
         *
         * Github has "Secondary Rate Limits" in case of excessive polling or very costly API calls.
         * GitHub guidance is to "wait a few minutes" when we get one of these errors.
         * https://docs.github.com/en/rest/overview/resources-in-the-rest-api#secondary-rate-limits
         * this link is REST specific - however, the limits might apply to GraphQL as well,
         * and our GraphQL client is not using the @octokit throttling and retry plugins like our REST client
         * therefore some retry logic is appropriate here
         */

        if (err.status === 401) {
          logger.warn(
            { attemptContext, err },
            `Hit 401, attempting to refresh the token and try again.`,
          );
          await this.refreshToken();
          return;
        }

        // don't keep trying if it's not going to get better
        if (err.retryable === false || err.status === 403) {
          logger.warn(
            { attemptContext, err },
            `Hit an unrecoverable error when attempting to query GraphQL. Aborting.`,
          );
          attemptContext.abort();
        }

        if (err.message?.includes('exceeded a secondary rate limit')) {
          logger.info(
            { attemptContext, err },
            '"Secondary Rate Limit" message received.',
          );
        }

        if (err.message?.includes('Resource not accessible by integration')) {
          logger.info(
            { attemptContext, err },
            'Resource not accessible by integration: Aborting attempt',
          );
          attemptContext.abort();
        }

        logger.warn(
          { attemptContext, err, queryString, queryVariables },
          `Hit a possibly recoverable error when attempting to query GraphQL. Waiting before trying again.`,
        );
      },
    });
  }
}
